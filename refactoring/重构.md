# 重构

## 1、代码的坏味道

1. 重复代码（Duplicated Code）
2. 超长方法(Long Method)
3. 超大类(Large Class)
4. 方法参数过长(Long Parameter List)
5. 发散式变化(Divergent Change)（不内聚，一个类受多种变化影响）
6. 霰弹式修改(Shotgun Surgery)（一种变化引发多个类相应修改）
7. 依恋情结(Feature Envy)
8. 数据泥团(Data Clumps)
9. 基本类型偏执(Primitive Obsession)
10. Switch Statements
11. 平行继承体系(Paraller Inheritance Hierarchies)
12. 冗赘类(Lazy Class)
13. 夸夸其谈未来性(Speculative Generality)
14. 令人迷惑的暂时字段(Temporary Field)
15. 过度耦合的消息链(Message Chains)
16. 中间人，不要过度使用中间对象，直接和负责的对象打交道(Middle Man)
17. 狎昵关系，可以使用新类来减少这种关系(Inappropriate Intimacy)
18. 异曲同工的类，根据用途重新命名，或反复Move Method将某系行为移入类直到两者协议一致(Alternative Classes with Difference Interfaces)
19. 不完美的类库（Incompete Library Class）
20. 幼稚的数据类(Data Class)
21. 被拒绝的遗赠，子类应该继承超类的函数和数据，但是如果不会引起困惑和问题，不必太在意(Refused bequest)
22. 过多的注释，尽量通过代码去说明一切(Comments)

## 2、重构列表

1. 重构手法的五个部分：名称、简短概要（能解决什么、应该做什么、速写图介绍）、动机、做法、范例
2. 寻找引用点，需要谨慎的查找出所有的引用点
3. 使用重构手法的时候需要随时知道自己在做什么，运用重构，仅仅是一个起点，需要不断提高自身重构能力

## 3、重新组织函数

### 3.1 提炼函数（Extract Method）

1. 创造一个新函数，根据这个函数的意图去命名（做什么而不是怎么做）
2. 将提炼出的代码从源代码复制到目标函数中
3. 检查被提炼出来的代码是否引用了“作用域限于原函数‘的变量，包含局部变量和源函数参数
4. 检查是否有”仅用于被提炼代码段“的临时变量，如果有，在目标函数中将其声明为临时变量
5. 检查被提炼出来的代码，看看是否有任何局部变量的值被压改变，如果有一个临时变量被改变了，则将目标函数处理成一个查询并将查询结果辅助给该变量；如果很难这样做或者不止一个变量被修改，则看你那先需要分解临时变量在进行提炼或者用查询代替临时变量
6. 将被提炼代码中需要读取的局部变量作为目标函数参数
7. 处理完所有局部变量后再进行编译
8. 再源函数中将被提炼代码块替换成对目标函数的调用
9. 编译测试

### 3.2 内联函数（Inline Method）

1. 检查函数，确保其不具有多态性
2. 找出该函数所有被调用点
3. 将所有的被调用点替换成函数本体
4. 编译测试
5. 删除该函数定义

### 3.3 内联临时变量（Inline Temp）

   很少单独使用，基本上是作为Replace Temp With Query的一部分使用

1. 检查给临时变量赋值的语句，确保等号右边的表达式没有副作用
2. 如果这个临时变量没有被声明为final，那可以将其声明为final，然后编译检查，确保该临时变量只被赋值一次
3. 找到该临时变量所有的引用点，将他们替换为“为临时变量赋值”的表达式
4. 每次修改后编译测试
5. 修改完所有的引用点后删除该临时变量的声明和赋值语句
6. 编译测试

### 3.4 以查询取代临时变量（Replace Temp With Query）

1. 找出只被赋值一次的临时变量

2. 将该临时变量声明为final

3. 编译

4. 将“对该临时变量赋值”的语句的等号右侧部分提炼到一个独立函数中

   **注意：首先将函数声明为private，如果后续确实需要放开再进行放开；其次确保提炼出来的函数无副作用，即不修改任何对象内容，如果有副作用，可以进行Separate Query From Modifler**

5. 编译测试

6. 再该临时变量身上实施Inline Temp

### 3.5 引入解释性变量（Introduce Explaining Variable）

1. 声明一个final临时变量，将待分解之复杂表达式中的一部分动作的结算结果赋值给他
2. 将表达式中的“运算结果”这一部分，替换为上述临时变量
3. 编译测试
4. 重复上述步骤，处理表达式中的剩余部分

**注意：如果Extract Method成本低，建议优先使用Extract Method**

### 3.6 分解临时变量（Split Temporary Variable）

**注意：循环变量和收集变量不在此范围内**

1. 在待分解变量的声明及其第一次被赋值处，修改其名称
2. 将新的临时变量声明为final
3. 以该临时变量的第二次赋值动作为界，修改此前对该临时变量的所有引用点，让他们引用新的临时变量
4. 在第二次赋值处，重新声明原先那个临时变量
5. 编译测试
6. 逐次重复上述过程，每次都在声明处对临时变量改名，并修改下次赋值之前的引用点

### 3.7 移除对参数的赋值（Remove Assignments to Parameters）

1. 建立一个临时变量，将待处理的参数值赋予它
2. 以“对参数的赋值“为界，将其之后所有对此参数的引用点，全部替换为”对此临时变量的引用“
3. 修改赋值语句，使其改为对新建之临时变赋值
4. 编译测试

**注意：如果代码的语义是按引用传递的，请在调用端检查调用后是否还使用了这个参数，也要检查有多少个按引用传递的参数被赋值后又被使用，请尽量只以return方式返回一个值，如果需要返回的不只一个，看看可否把需返回的大堆数据变成单一对象，或干脆为每个返回值设计对应的一个独立函数**

### 3.8 以函数对象取代函数（Replace Method with Method Object）

​	**场景：先Replace Method with Method Object，再Extract Method**

1. 建立一个新类，根据待处理函数的用途，为这个类命名
2. 在新类中建立一个final字段，用以保存原先大型函数所在的对象，我们将这个字段称为”源对象“。同时，针对原函数的每个临时变量和每个参数，在新类中建议一个对应的字段保存之
3. 在新类中建立一个构造函数，接收源对象及原函数的所有参数作为参数
4. 在新类中建立一个compute（）函数
5. 将原函数的代码复制到compute（）函数中。如果需要调用源对象的任何函数，请通过源对象字段调用
6. 编译
7. 将就函数的本体替换为这样一句话：”创建一个上述新类的一个新对象，然后调用该对象的compute（）函数“

### 3.9 替换算法

1. 准备好替换算法，让它通过编译
2. 针对现有测试，执行上述的新算法。如果结果与原本结果相同，重构结束
3. 如果测试结果不同于原先，在测试和调试过程中，以旧算法为比较参照标准

## 4 在对象之前搬移特性

### 4.1 搬移函数（Move Method）

1. 检查源类中被源函数所使用的一切特性（包括字段和函数），考虑他们是否也该被迁移
2. 检查源类的子类和超类，看看是否有该函数的其他声明
3. 在目标类中声明这个函数
4. 将源函数的代码复制到目标函数中。调整后者，使其能在新家中正常运行
5. 编译目标类
6. 决定如何从源函数正确引用目标对象
7. 修改源函数，使之成为一个纯委托函数
8. 编译测试
9. 决定是否删除源函数，或将它作为一个委托函数保留下来
10. 如果要移除源函数，请将源类中对源函数的所有调用，替换为对目标函数的调用

### 4.2 搬移字段（Move Field）

1. 如果字段的访问级别是public，使用Encapsulate Field将它封装起来
2. 编译测试
3. 在目标类中建立与源字段相同的字段，并同时建议相应的设值/取值函数
4. 编译目标类
5. 决定如何在源对象中引用目标对象
6. 删除源字段
7. 将所有对源字段的引用替换成对某个目标函数的调用
8. 编译测试

### 4.3 提炼类（Extract Class）

1. 决定如何分解类所负的责任
2. 建立一个新类，用以表现从旧类分离出来的责任，旧类可以按照剩余的责任更名
3. 建立“从旧类到新类”的连接关系，除非必须，否则不要建立双向连接
4. 对于你想搬移的每一个字段，采用Move Field搬移之
5. 每次搬移后，编译测试
6. 使用Move Method将必要函数搬移到新类，先搬移较低层次函数（“被其他函数调用”多于“调用其他函数”者），再搬移较高层函数
7. 每次搬移后编译测试
8. 检查，精简每个类的接口
9. 决定是否公开新类。如果需要公开，就要决定让它成为引用对象还是不可变的值对象

### 4.4 内联类（Inline Class）

1. 在目标类身上声明源类的public协议，并将其中所有函数委托至源类
2. 修改所有源类引用点，改而引用目标类
3. 编译测试
4. 运用Move Method和Move Field将源类的特性全部搬移到目标类
5. 删除源类

### 4.5 隐藏“委托关系”（Hide Delegate）

1. 对于每一个委托关系中的函数，在服务对象端建立一个简单的委托函数
2. 调整客户，令他只调用服务对象提供的函数
3. 每次调整后，编译测试
4. 如果将来不再有任客户不需要取用受托类，便可移除服务对象中的相关访问函数
5. 编译测试

### 4.6 移除中间人（Remove Middle Man）

1. 建立一个函数，用以获得委托对象
2. 对于每个委托函数，在服务类中删除该函数，并让需要调用该函数的客户端转为调用受托对象
3. 处理每个委托函数后，编译测试

Remove Middle Man 与 Hide Delegate 随时按照代码需要进行切换

### 4.7 引入外加函数（Introduce Foreign Method）

1. 在客户类中建立一个函数，用来提供你需要的功能
2. 以服务类实例作为该函数的第一个参数
3. 将该函数注释为：“外加函数，应在服务类中实现”

### 4.8 引入本地拓展

1. 建立一个拓展类，将他作为原始类的子类或者包装类
2. 在拓展类中加入转型构造函数
3. 在拓展类中加入新特性
4. 根据需要i，将原对象替换为拓展对象
5. 将针对原始类定义的所有外加函数搬移到拓展类中

## 5 重新组织数据

### 5.1 自封装字段（Self Encapsulate Field）

1. 为待封装字段建立取值/设值函数
2. 找出该字段的所有引用点，将他们替换为调用取值/设值函数
3. 将该字段声明为private
4. 复查，确保找出所有引用点
5. 编译测试

**好处：子类可以通过覆写一个函数而改变获取数据的途径；还支持灵活的数据管理方式，例如延迟加载**

**建议：一般情况下没必要进行自封装，但是如果直接访问会带来麻烦，那就进行重构**

### 5.2 以对象取代数据值(Replace Data Value with Object)

1. 为待替换数值建立一个新类，在其中声明一个final字段，其类型与源类中的待替换数值类型一样。任何在新类中加入这个字段的取值函数，再加上一个接受此字段作为参数的构造函数
2. 编译
3. 将源类中的待替换数值字段的类型改为前面新建的类
4. 修改源类中该字段的取值函数，令它调用新类的取值函数
5. 如果源类的构造函数中有用到这个字段，我们就修改构造函数，令它改用新类的构造函数对字段进行赋值动作
6. 修改源类中待替换字段的设值函数，令它为新类创建一个新的实例
7. 编译测试
8. 对新类使用Change Value to Reference

### 5.3 将值对象改为引用对象（Replace Value to Reference）

1. 使用Replace Constructor with Factory Method
2. 编译测试
3. 决定由声明对象负责提供访问新对象的途径
4. 决定这些引用对象先创建好，或是应该动态创建
5. 修改工厂函数，令它返回引用对象
6. 编译测试

### 5.4 将引用对象改为值对象（Change Reference to Value）

1. 检查重构对象是不是不可变对象，或是否可修改为不可变对象
2. 建议equals()和hasCode()方法
3. 编译测试
4. 考虑是否可以删除工厂函数，并将构造函数声明为public

### 5.5 以对象取代数组（Replace Array with Object）

1. 新建一个类表示数组所拥有的信息，并在其中以一个public字段保存原有的数组
2. 修改数组的所有用户，让他们改用新类的实例
3. 编译测试
4. 逐一为数组元素添加设值/取值函数。根据元素的用途，为这些访问函数命名。修改客户端代码，让他们通过通过访问函数取用数组内的元素，每次修改后编译测试
5. 当所有对数组的直接访问都转而调用访问函数后，将新类中保存该数组的字段声明为private
6. 编译
7. 对于数组内的每一个元素，在新类中创建一个类型相当的字段，修改该元素的访问函数，令它改用上述的新建字段
8. 每修改一个元素编译测试
9. 数组的所有元素都有了相信的字段后删除该数组

### 5.6 复制被监视数据（Duplicate Observed Data）

```
// TODO
暂时看不懂GUI控件是什么，待后面补充
```

### 5.7 将单向关联改为双向关联（Change Unidirectional Association to Bidirection）

1. 在被引用类中增加一个字段，用以保存反向指针
2. 决定由哪个类-引用端还是被引用端-控制关联关系
3. 在被控端建立一个辅助函数，其命名应该清楚指出它的有限用途
4. 如果既有的修改函数在控制端，让他负责更新反向指针
5. 如果既有的修改函数在被控制端，就在控制端建立一个控制函数，并让既有的控制函数调用这个新建的控制函数 

### 5.8 将双向关联改为单向关联（Change Bidirection Association to Unidirectional）

1. 找出保存“你想去除的指针”的字段，检查它的每一个用户，判断是否可删除该指针
2. 如果客户使用了取值函数，先运用Self Encapsulate Field将待删除字段自我封装起来，然后使用Substitute Algorithm对付取值函数，令它不再使用该字段，然后编译测试
3. 如果客户并未使用取值函数，那就直接修改待删除字段所有的引用点：改以其他途径获得该字段保存的对象，每次修改后编译测试
4. 如果已经没有任何函数使用待删除字段，移除所有对该字段的更新逻辑，然后移除该字段
5. 编译测试

### 5.9 以字面常量取代魔法数（Replace Magic Number with Symbolic Constant）

1. 声明一个常量，令其值为原本的魔法数值
2. 找出这个魔法数所有的引用点
3. 检查是否可以使用这个新声明的常量来代替该魔法数，如果可以，使用该常量替换之
4. 编译
5. 所有魔法数都被替换完毕后，编译测试，此时整个程序应该运转如常，就象没有做过任何修改一样