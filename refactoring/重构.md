# 重构

## 1、代码的坏味道

1. 重复代码（Duplicated Code）
2. 超长方法(Long Method)
3. 超大类(Large Class)
4. 方法参数过长(Long Parameter List)
5. 发散式变化(Divergent Change)（不内聚，一个类受多种变化影响）
6. 霰弹式修改(Shotgun Surgery)（一种变化引发多个类相应修改）
7. 依恋情结(Feature Envy)
8. 数据泥团(Data Clumps)
9. 基本类型偏执(Primitive Obsession)
10. Switch Statements
11. 平行继承体系(Paraller Inheritance Hierarchies)
12. 冗赘类(Lazy Class)
13. 夸夸其谈未来性(Speculative Generality)
14. 令人迷惑的暂时字段(Temporary Field)
15. 过度耦合的消息链(Message Chains)
16. 中间人，不要过度使用中间对象，直接和负责的对象打交道(Middle Man)
17. 狎昵关系，可以使用新类来减少这种关系(Inappropriate Intimacy)
18. 异曲同工的类，根据用途重新命名，或反复Move Method将某系行为移入类直到两者协议一致(Alternative Classes with Difference Interfaces)
19. 不完美的类库（Incompete Library Class）
20. 幼稚的数据类(Data Class)
21. 被拒绝的遗赠，子类应该继承超类的函数和数据，但是如果不会引起困惑和问题，不必太在意(Refused bequest)
22. 过多的注释，尽量通过代码去说明一切(Comments)

## 2、重构列表

1. 重构手法的五个部分：名称、简短概要（能解决什么、应该做什么、速写图介绍）、动机、做法、范例
2. 寻找引用点，需要谨慎的查找出所有的引用点
3. 使用重构手法的时候需要随时知道自己在做什么，运用重构，仅仅是一个起点，需要不断提高自身重构能力

## 3、重新组织函数

### 3.1 提炼函数（Extract Method）

1. 创造一个新函数，根据这个函数的意图去命名（做什么而不是怎么做）
2. 将提炼出的代码从源代码复制到目标函数中
3. 检查被提炼出来的代码是否引用了“作用域限于原函数‘的变量，包含局部变量和源函数参数
4. 检查是否有”仅用于被提炼代码段“的临时变量，如果有，在目标函数中将其声明为临时变量
5. 检查被提炼出来的代码，看看是否有任何局部变量的值被压改变，如果有一个临时变量被改变了，则将目标函数处理成一个查询并将查询结果辅助给该变量；如果很难这样做或者不止一个变量被修改，则看你那先需要分解临时变量在进行提炼或者用查询代替临时变量
6. 将被提炼代码中需要读取的局部变量作为目标函数参数
7. 处理完所有局部变量后再进行编译
8. 再源函数中将被提炼代码块替换成对目标函数的调用
9. 编译测试

### 3.2 内联函数（Inline Method）

1. 检查函数，确保其不具有多态性
2. 找出该函数所有被调用点
3. 将所有的被调用点替换成函数本体
4. 编译测试
5. 删除该函数定义

### 3.3 内联临时变量（Inline Temp）

   很少单独使用，基本上是作为Replace Temp With Query的一部分使用

1. 检查给临时变量赋值的语句，确保等号右边的表达式没有副作用
2. 如果这个临时变量没有被声明为final，那可以将其声明为final，然后编译检查，确保该临时变量只被赋值一次
3. 找到该临时变量所有的引用点，将他们替换为“为临时变量赋值”的表达式
4. 每次修改后编译测试
5. 修改完所有的引用点后删除该临时变量的声明和赋值语句
6. 编译测试

### 3.4 以查询取代临时变量（Replace Temp With Query）

1. 找出只被赋值一次的临时变量

2. 将该临时变量声明为final

3. 编译

4. 将“对该临时变量赋值”的语句的等号右侧部分提炼到一个独立函数中

   **注意：首先将函数声明为private，如果后续确实需要放开再进行放开；其次确保提炼出来的函数无副作用，即不修改任何对象内容，如果有副作用，可以进行Separate Query From Modifler**

5. 编译测试

6. 再该临时变量身上实施Inline Temp

### 3.5 引入解释性变量（Introduce Explaining Variable）

1. 声明一个final临时变量，将待分解之复杂表达式中的一部分动作的结算结果赋值给他
2. 将表达式中的“运算结果”这一部分，替换为上述临时变量
3. 编译测试
4. 重复上述步骤，处理表达式中的剩余部分

**注意：如果Extract Method成本低，建议优先使用Extract Method**

### 3.6 分解临时变量（Split Temporary Variable）

**注意：循环变量和收集变量不在此范围内**

1. 在待分解变量的声明及其第一次被赋值处，修改其名称
2. 将新的临时变量声明为final
3. 以该临时变量的第二次赋值动作为界，修改此前对该临时变量的所有引用点，让他们引用新的临时变量
4. 在第二次赋值处，重新声明原先那个临时变量
5. 编译测试
6. 逐次重复上述过程，每次都在声明处对临时变量改名，并修改下次赋值之前的引用点

### 3.7 移除对参数的赋值（Remove Assignments to Parameters）

1. 建立一个临时变量，将待处理的参数值赋予它
2. 以“对参数的赋值“为界，将其之后所有对此参数的引用点，全部替换为”对此临时变量的引用“
3. 修改赋值语句，使其改为对新建之临时变赋值
4. 编译测试

**注意：如果代码的语义是按引用传递的，请在调用端检查调用后是否还使用了这个参数，也要检查有多少个按引用传递的参数被赋值后又被使用，请尽量只以return方式返回一个值，如果需要返回的不只一个，看看可否把需返回的大堆数据变成单一对象，或干脆为每个返回值设计对应的一个独立函数**

### 3.8 以函数对象取代函数（Replace Method with Method Object）

​	**场景：先Replace Method with Method Object，再Extract Method**

1. 建立一个新类，根据待处理函数的用途，为这个类命名
2. 在新类中建立一个final字段，用以保存原先大型函数所在的对象，我们将这个字段称为”源对象“。同时，针对原函数的每个临时变量和每个参数，在新类中建议一个对应的字段保存之
3. 在新类中建立一个构造函数，接收源对象及原函数的所有参数作为参数
4. 在新类中建立一个compute（）函数
5. 将原函数的代码复制到compute（）函数中。如果需要调用源对象的任何函数，请通过源对象字段调用
6. 编译
7. 将就函数的本体替换为这样一句话：”创建一个上述新类的一个新对象，然后调用该对象的compute（）函数“

### 3.9 替换算法

1. 准备好替换算法，让它通过编译
2. 针对现有测试，执行上述的新算法。如果结果与原本结果相同，重构结束
3. 如果测试结果不同于原先，在测试和调试过程中，以旧算法为比较参照标准

## 4 在对象之前搬移特性

### 4.1 搬移函数（Move Method）

1. 检查源类中被源函数所使用的一切特性（包括字段和函数），考虑他们是否也该被迁移
2. 检查源类的子类和超类，看看是否有该函数的其他声明
3. 在目标类中声明这个函数
4. 将源函数的代码复制到目标函数中。调整后者，使其能在新家中正常运行
5. 编译目标类
6. 决定如何从源函数正确引用目标对象
7. 修改源函数，使之成为一个纯委托函数
8. 编译测试
9. 决定是否删除源函数，或将它作为一个委托函数保留下来
10. 如果要移除源函数，请将源类中对源函数的所有调用，替换为对目标函数的调用

### 4.2 搬移字段（Move Field）

1. 如果字段的访问级别是public，使用Encapsulate Field将它封装起来
2. 编译测试
3. 在目标类中建立与源字段相同的字段，并同时建议相应的设值/取值函数
4. 编译目标类
5. 决定如何在源对象中引用目标对象
6. 删除源字段
7. 将所有对源字段的引用替换成对某个目标函数的调用
8. 编译测试

### 4.3 提炼类（Extract Class）

1. 决定如何分解类所负的责任
2. 建立一个新类，用以表现从旧类分离出来的责任，旧类可以按照剩余的责任更名
3. 建立“从旧类到新类”的连接关系，除非必须，否则不要建立双向连接
4. 对于你想搬移的每一个字段，采用Move Field搬移之
5. 每次搬移后，编译测试
6. 使用Move Method将必要函数搬移到新类，先搬移较低层次函数（“被其他函数调用”多于“调用其他函数”者），再搬移较高层函数
7. 每次搬移后编译测试
8. 检查，精简每个类的接口
9. 决定是否公开新类。如果需要公开，就要决定让它成为引用对象还是不可变的值对象

### 4.4 内联类（Inline Class）

1. 在目标类身上声明源类的public协议，并将其中所有函数委托至源类
2. 修改所有源类引用点，改而引用目标类
3. 编译测试
4. 运用Move Method和Move Field将源类的特性全部搬移到目标类
5. 删除源类

### 4.5 隐藏“委托关系”（Hide Delegate）

1. 对于每一个委托关系中的函数，在服务对象端建立一个简单的委托函数
2. 调整客户，令他只调用服务对象提供的函数
3. 每次调整后，编译测试
4. 如果将来不再有任客户不需要取用受托类，便可移除服务对象中的相关访问函数
5. 编译测试

### 4.6 移除中间人（Remove Middle Man）

1. 建立一个函数，用以获得委托对象
2. 对于每个委托函数，在服务类中删除该函数，并让需要调用该函数的客户端转为调用受托对象
3. 处理每个委托函数后，编译测试

Remove Middle Man 与 Hide Delegate 随时按照代码需要进行切换

### 4.7 引入外加函数（Introduce Foreign Method）

1. 在客户类中建立一个函数，用来提供你需要的功能
2. 以服务类实例作为该函数的第一个参数
3. 将该函数注释为：“外加函数，应在服务类中实现”

### 4.8 引入本地拓展

1. 建立一个拓展类，将他作为原始类的子类或者包装类
2. 在拓展类中加入转型构造函数
3. 在拓展类中加入新特性
4. 根据需要i，将原对象替换为拓展对象
5. 将针对原始类定义的所有外加函数搬移到拓展类中

## 5 重新组织数据

### 5.1 自封装字段（Self Encapsulate Field）

1. 为待封装字段建立取值/设值函数
2. 找出该字段的所有引用点，将他们替换为调用取值/设值函数
3. 将该字段声明为private
4. 复查，确保找出所有引用点
5. 编译测试

**好处：子类可以通过覆写一个函数而改变获取数据的途径；还支持灵活的数据管理方式，例如延迟加载**

**建议：一般情况下没必要进行自封装，但是如果直接访问会带来麻烦，那就进行重构**

### 5.2 以对象取代数据值(Replace Data Value with Object)

1. 为待替换数值建立一个新类，在其中声明一个final字段，其类型与源类中的待替换数值类型一样。任何在新类中加入这个字段的取值函数，再加上一个接受此字段作为参数的构造函数
2. 编译
3. 将源类中的待替换数值字段的类型改为前面新建的类
4. 修改源类中该字段的取值函数，令它调用新类的取值函数
5. 如果源类的构造函数中有用到这个字段，我们就修改构造函数，令它改用新类的构造函数对字段进行赋值动作
6. 修改源类中待替换字段的设值函数，令它为新类创建一个新的实例
7. 编译测试
8. 对新类使用Change Value to Reference

### 5.3 将值对象改为引用对象（Replace Value to Reference）

1. 使用Replace Constructor with Factory Method
2. 编译测试
3. 决定由声明对象负责提供访问新对象的途径
4. 决定这些引用对象先创建好，或是应该动态创建
5. 修改工厂函数，令它返回引用对象
6. 编译测试

### 5.4 将引用对象改为值对象（Change Reference to Value）

1. 检查重构对象是不是不可变对象，或是否可修改为不可变对象
2. 建议equals()和hasCode()方法
3. 编译测试
4. 考虑是否可以删除工厂函数，并将构造函数声明为public

### 5.5 以对象取代数组（Replace Array with Object）

1. 新建一个类表示数组所拥有的信息，并在其中以一个public字段保存原有的数组
2. 修改数组的所有用户，让他们改用新类的实例
3. 编译测试
4. 逐一为数组元素添加设值/取值函数。根据元素的用途，为这些访问函数命名。修改客户端代码，让他们通过通过访问函数取用数组内的元素，每次修改后编译测试
5. 当所有对数组的直接访问都转而调用访问函数后，将新类中保存该数组的字段声明为private
6. 编译
7. 对于数组内的每一个元素，在新类中创建一个类型相当的字段，修改该元素的访问函数，令它改用上述的新建字段
8. 每修改一个元素编译测试
9. 数组的所有元素都有了相信的字段后删除该数组

### 5.6 复制被监视数据（Duplicate Observed Data）

```
// TODO
暂时看不懂GUI控件是什么，待后面补充
```

### 5.7 将单向关联改为双向关联（Change Unidirectional Association to Bidirection）

1. 在被引用类中增加一个字段，用以保存反向指针
2. 决定由哪个类-引用端还是被引用端-控制关联关系
3. 在被控端建立一个辅助函数，其命名应该清楚指出它的有限用途
4. 如果既有的修改函数在控制端，让他负责更新反向指针
5. 如果既有的修改函数在被控制端，就在控制端建立一个控制函数，并让既有的控制函数调用这个新建的控制函数 

### 5.8 将双向关联改为单向关联（Change Bidirection Association to Unidirectional）

1. 找出保存“你想去除的指针”的字段，检查它的每一个用户，判断是否可删除该指针
2. 如果客户使用了取值函数，先运用Self Encapsulate Field将待删除字段自我封装起来，然后使用Substitute Algorithm对付取值函数，令它不再使用该字段，然后编译测试
3. 如果客户并未使用取值函数，那就直接修改待删除字段所有的引用点：改以其他途径获得该字段保存的对象，每次修改后编译测试
4. 如果已经没有任何函数使用待删除字段，移除所有对该字段的更新逻辑，然后移除该字段
5. 编译测试

### 5.9 以字面常量取代魔法数（Replace Magic Number with Symbolic Constant）

1. 声明一个常量，令其值为原本的魔法数值
2. 找出这个魔法数所有的引用点
3. 检查是否可以使用这个新声明的常量来代替该魔法数，如果可以，使用该常量替换之
4. 编译
5. 所有魔法数都被替换完毕后，编译测试，此时整个程序应该运转如常，就象没有做过任何修改一样

### 5.10 封装字段（Encapsulate Field）

1. 为public字段提供取值/设值函数
2. 找到这个类以外使用该字段的所有地点。如果客户只是读取该字段，就把引用替换为对取值函数的调用；如果客户修改了该字段值，就将此引用点替换为对设值函数的调用
3. 每次修改之后编译测试
4. 将该字段的所有用户修改完毕后，把该字段声明为private
5. 编译测试

### 5.11 封装集合（Encapsulate Collection）

1. 加入为集合添加/删除元素的函数
2. 将保存集合的字段初始化为一个空集合
3. 找出集合设置函数所有的调用者，你可以修改那个设置函数，让他使用上述新添加的“添加/删除元素”函数；也可以直接修改调用端，改让他们调用上述新添加的“添加/删除元素”函数
4. 编译测试
5. 找出所有“通过取值函数获得集合并修改其内容”的函数，逐一修改这些函数，让它们改用添加/删除函数，每次修改后编译测试
6. 修改完上述所有的函数后，修改取值函数本身，使它返回该集合的一个只读副本
7. 编译测试
8. 找出取值函数的所有用户，从中找出应该存在于集合所属对象内的代码。运用Extract Method和Move Method将这些代码移到宿主对象上去
9. 修改现有取值函数的名字，然后添加一个新取值函数，使其返回一个枚举，找出旧取值函数的所有被使用点，将他们都改为使用新取值函数
10. 如果这一步跨步太大，可以先使用Rename Method修改原取值函数的名称，在建立一个新取值函数用于返回枚举，最后在修改所有调用者，使其调用新取值函数
11. 编译测试

### 5.12 以数据类取代记录（Replace Record with Data Class）

1. 新建一个类，表示这个记录
2. 对于记录中的每一项数据，在新建的类中建立一个对应的private字段，并提供相应的取值/赋值函数

### 5.13 以类取代类型码（Replace Type Code with Class）

1. 为类型码新建一个类
2. 修改源类实现，让它使用上述新建的类
3. 编译测试
4. 对于源类中的每一个使用类型码的函数，相应建立一个函数，让新函数使用新建的类
5. 逐一修改源类的用户，让他们使用新函数
6. 每修改一个用户编译测试
7. 删除使用类型码的旧接口，并删除保存旧类型码的静态变量
8. 编译测试

### 5.14 以子类取代类型码（Replace Type Code with Subclasses）

1. 使用self encapsulated field将类型码自我封装
2. 为类型码的每一个数值都建立一个相应的子类，在每个子类中覆写类型码的取值函数，使其返回相应的类型码值
3. 每建立一个新的子类编译测试
4. 从超类中删掉保存类型码的字段，将类型码访问函数声明为抽象函数
5. 编译测试

### 5.15 以State/Strategy取代类型码（Replace Type Code with State/Strategy）

1. 使用self encapsulated field将类型码自我封装
2. 新建一个类，根据类型码的用途为他命名，这就是一个状态对象
3. 为这个新类添加子类，每个子类对应一个类型码
4. 在超类中建立一个抽象的查询函数，用以返回类型码，在每个子类中覆写该函数，返回确切的类型码
5. 编译
6. 在源类中建立一个字段，用以保存新建的对象状态
7. 调整源类中负责查询类型码的函数，将查询动作转发给状态对象
8. 调整源类中为类型码设置的函数，将一个恰当的状态对象子类赋值给保存状态对象的那个字段
9. 编译测试

### 5.16 以字段取代子类Replace Type Code with State/Strategy）

1. 对所有子类使用replace constructor with factory method
2. 如果有任何代码直接引用子类，令它改用超类
3. 针对每个常量函数，在超类中声明一个final字段
4. 为超类声明一个protect构造函数，用以初始化这些新增字段
5. 新建或修改子类构造函数，使它调用超类的新增构造函数
6. 编译测试
7. 在超类中实现所有变量函数，令他们返回相应的字段，任何将该函数从子类中删除
8. 编译测试
9. 子类中所有的常量函数都被删除后，使用inline method将子类构造函数内联到超累的工厂函数中
10. 编译测试
11. 将子类删除
12. 编译测试
13. 重复内联构造函数、删除子类过程，直到所有子类被删除

## 6 简化条件表达式

### 6.1 分解条件表达式（Decompose Conditional）

1. 将if段落提炼出来，构成一个独立函数
2. 将then段落和else段落都提炼出来，各种构造一个独立函数

### 6.2  合并条件表达式（Consolidate Conditional Expression）

1. 确保这些表达式没有副作用
2. 使用适当的逻辑操作符，将一系列相关条件表达式合并为一个
3. 编译测试
4. 对合并后的条件表达式实施Extract Method

### 6.3 合并重复的条件分段（Consolidate Duplicate Conditional Fragments）

1. 鉴别出“执行方式不随条件变化而变化”的代码
2. 如果这些共通代码位于条件表达式起始处，就将它移到条件表达式之前
3. 如果这些共通代码位于条件表达式尾端，就将它移到条件表达式之后
4. 如果这些代码位于中段，先观察这些共同代码之前或之后的代码是否改变了声明东西，如果有改变，则应该将这些代码移至条件表达式的起始处或尾端，在以之前的做法来处理
5. 如果共同代码不止一条语句，先使用Extract Method提炼单独的函数在按照之前的方法处理

### 6.4 移除控制标记（Remove Control Flag）

如果有break或者continue语句

1. 找出让你跳出这段逻辑的控制标记值
2. 找出对标记变量赋值的语句，代以恰当的break语句或continue语句
3. 每次替换后编译测试

如果没有break或者continue语句

1. 运用Extract Method 将整段逻辑提炼到一个单独的函数中
2. 找出让你跳出这段逻辑的控制标记值
3. 找出对标记变量赋值的语句，代以恰当的return语句
4. 每次替换后编译测试

### 6.5 以卫语句取代嵌套条件表达式（Replace Nested Condition with Guard Clauses）

1. 对于每个检查，放进一个卫语句
2. 每次将条件替换成卫语句后编译测试

### 6.6 以多态取代条件表达式（Replace Condition with Polymorphism）

1. 如果要处理的条件表达式是一个更大函数的一部分，先对该条件表达式进行分析，使用Extract Method进行提炼
2. 如果有必要使用Move Method将条件表达式放到继承结构的顶端
3. 任选一个子类，使之覆盖超类中覆盖该条件表达式的函数，将与该子类相关的条件表达式分支复制到新建的函数中，并进行相应的调整
4. 编译测试
5. 在超类中删除条件表达式已被复制的分支
6. 编译测试
7. 重复上述过程，直到所有分支都完成迁移
8. 将超类中容纳该条件表达式的函数声明为抽象函数

###  6.7 引入null对象（Introduce Null Object）

1. 为源类建立一个子类，在二者内各创建一个isNull函数，源类返回false，子类返回true
2. 编译
3. 找到所有索求源对象却获取到null的地方，修改这些地方，使他们改而获得一个空对象
4. 找出所有将源对象与null比较的地方，修改这些地方，使他们调用isNull函数
5. 编译测试
6. 找出这样的程序点：如果对象不是null，执行A，否则执行B
7. 对于每一个上述地点，在子类中覆写A动作，使其行为与B相同
8. 使用上述被覆盖的动作，任何删除对象是否为null的条件测试
9. 编译测试

### 6.8 引入断言（Introduce Assertion）

1. 如果你发现代码假设某个条件始终为真，就加入一个断言明确说明这种情况

## 7 简化函数调用

### 7.1函数改名（Rename Method）

1. 检查函数签名是否被超类或子类实现过，如果是，则需要针对所有实现分别进行下列步骤
2. 声明一个新函数，按照实现内容进行命名，将旧函数代码迁移过来，并进行适当调整
3. 编译
4. 修改旧函数，令其调用新函数
5. 编译测试
6. 找到所有旧函数引用点，替换成调用新函数
7. 每次替换后编译测试
8. 删除旧函数
9. 编译测试

### 7.2 添加参数（Add Parameter）

1. 检查函数签名是否被超类或子类实现过，如果是，则需要针对所有实现分别进行下列步骤
2. 声明一个新函数，按照实现内容进行命名，将旧函数代码迁移过来，并进行适当调整
3. 编译
4. 修改旧函数，令其调用新函数
5. 编译测试
6. 找到所有旧函数引用点，替换成调用新函数
7. 每次替换后编译测试
8. 删除旧函数
9. 编译测试

### 7.3 去除参数（Remove Parameter）

1. 检查函数签名是否被超类或子类实现过，如果是，则需要针对所有实现分别进行下列步骤
2. 声明一个新函数，按照实现内容进行命名，将旧函数代码迁移过来，并进行适当调整
3. 编译
4. 修改旧函数，令其调用新函数
5. 编译测试
6. 找到所有旧函数引用点，替换成调用新函数
7. 每次替换后编译测试
8. 删除旧函数
9. 编译测试

### 7.4 将查询函数与修改函数分离（Separate Query from Modifier）

1. 新建一个查询函数，返回值类型与原函数相同
2. 修改原函数，令它调用查询函数并返回结果
3. 编译测试
4. 将调用原函数的代码改为调用查询函数，任何在调用查询函数前加上对原函数的调用，每次修改后编译测试
5. 将原函数的返回值修改为void，并删除其中的return语句

**注意：在多线程中需要建立一个第三函数来调用该查询函数和修改函数，并将此第三函数声明为synchronized,如果查询函数和修改函数没有被声明为synchronized，则需要它们的访问级别限制成包级别或者private级别**

### 7.5 令函数携带参数（Parameterize Method）

1. 新建一个带有参数的函数，使它可以替换先前所有的重复性函数
2. 编译
3. 将调用旧函数的地方改成调用新函数
4. 编译测试
5. 对所有旧函数重复上述过程，每次替换后编译测试

### 7.6 以明确函数取代参数（Replace Parameter with Explicit Method）

1. 针对参数的每一种可能性，新建一个明确的函数
2. 修改条件表达式的每个分支，使其调用新建的函数
3. 修改每个分支后编译测试
4. 修改原函数的每一个被调用点，改成调用上述合适的新函数
5. 编译测试
6. 全部测试完毕后删除原函数

### 7.7 保持对象完整（Preserve Whole Object）

1. 对你的目标函数新添一个参数项，用以代表原数据所在的完整对象
2. 编译测试
3. 判断哪些数据可被包含在新的对象中
4. 选择上述参数之一，将被调用函数中原来引用该参数的地方，改为调用该新添对象对应的取值函数
5. 删除该参数
6. 编译测试
7. 重复上过程直到所有可被替换的参数被替换完毕
8. 删除调用端那些带有被删除参数的代码
9. 编译测试

### 7.8 以函数取代参数（Replace Parameter with Method）

1. 如果有必要，将参数的计算过程提炼到一个独立函数中
2. 将函数本体内引用该参数的地方改为调用上述函数
3. 每次替换后编译测试
4. 全部替换完之后，采用Remove Parameter将该参数删除

### 7.9 引入参数对象（Introduce Parameter Object）

1. 新建一个类，用以表现你想替换的一组参数，声明这个类为final
2. 编译
3. 针对使用该参数的所有函数，采用Add Parameter ,传入上述新建类的实例对象，并将其设为null
4. 对应Data Clumps的每一项，从函数签名中删除，并修改调用端和函数本体，令他们都改为通过新的参数对象取得该值
5. 每移除一个参数，编译测试
6. 原参数全部去除后，观察是否是合适的函数可以用Move Method搬移到新的参数对象中

### 7.10 移除设置函数（Remove Setting Method）

1. 检查设置函数被调用的情况，看他是否只被构造参数调用，或者被构造函数所调用的另一个函数所调用
2. 修改构造参数，使其直接访问设置函数所针对的那个变量
3. 编译测试
4. 移除这个设置函数，将他所针对的所有字段声明修改为final
5. 编译测试

### 7.11 隐藏函数（Hide Method）

1. 经常检查有没有可能降低某个函数的可见度
2. 尽可能降低函数的可见度
3. 没完成一组函数的隐藏后编译测试

### 7.12 以工厂函数取代构造函数（Replace Constructor with Factory Method）

1. 新建一个工厂函数，让它调用现有的构造函数
2. 将调用构造函数的地方修改为调用工厂函数
3. 每次替换后编译测试
4. 将构造参数声明为private
5. 编译

### 7.13 封装向下转型（Encapsulate Downcast）

1. 找出必须对函数调用结果进行向下转型的地方
2. 将向下转型动作搬移到该函数中

### 7.14 以异常取代异常码（Replace Error Code with Exception）

1. ​	决定抛出受检异常还是非受检异常
2. 新建一个函数，使用异常来表示错误情况，将旧函数的代码复制到新函数中并做适当的调整
3. 修改旧函数的本体，让它调用新函数，如果调用者很少，也可以直接令其调用者调用新函数
4. 编译测试
5. 逐一修改旧函数的调用者，令其调用者调用新函数。每次修改后编译测试
6. 删除旧函数

### 7.15 以测试取代异常（Replace Exception with Test）

1. 在函数调用点之前，放置一个测试语句，将函数内catch区段中的代码复制到测试语句的适当if分支中
2. 在catch区段起始处加入一个断言，确保该区段不会被执行
3. 编译测试
4. 删除所有catch区段，然后把try区段内的所有代码复制到区段外，然后删除try区段
5. 编译测试

## 8 处理概括关系

### 8.1 字段上移（Pull Up Field）

1. 针对待提升字段，检查它们所有的被使用点，确认它们以同样的方式被使用
2. 如果这些字段名称不同，先修改它们的名称，保持它们的名字和你在超类中准备创建的字段相同
3. 编译测试
4. 在超类中新建一个字段
5. 移除子类中的字段
6. 编译测试
7. 考虑对新建的字段使用Self Encapsulate Field

### 8.2 函数上移（Pull Up Method）

1. 检查待上移函数，确保它们都是完全一致的
2. 如果待上移函数的签名不同，将那些签名都修改为你想在超类中使用的签名
3. 在超类中新建一个函数，将待上移函数的代码复制进来并做适当的调整，编译
4. 移除一个待上移的子类函数
5. 编译测试
6. 逐一移除所有的子类函数，每次移除后编译
7. 观察该函数的调用者，看看是否可修改为调用超类对象

### 8.3 构造参数本体上移（Pull Up Constructor Body）

1. 在超类中创建一个构造函数
2. 将子类构造函数中的共同代码搬移到超类构造函数中
3. 将子类构造函数中的共同代码删掉，改成调用超类的构造函数
4. 编译测试

### 8.4 函数下移（Pull Down Method） 

1. 在所有子类中声明该函数，将超类中的代码复制到每个子类函数中
2. 删除超类中的函数
3. 编译测试
4. 将该函数从不需要它的子类中删除
5. 编译测试

### 8.5 字段下移（Pull Down Field）

1. 在所有子类中声明该字段
2. 删除超类中的该字段
3. 编译测试
4. 将该字段从不需要它的子类中删除
5. 编译测试

### 8.6 提炼子类（Extract Subclass）

1. 为源类创建一个子类，并在子类中提供构造函数
2. 找出调用超类构造函数的所有调用点，如果它们需要的是新建的子类，则改为调用子类的构造函数
3. 逐一使用Pull Down Method 和Pull Down Field将源类的特性下移到该子类中
4. 找到这样的字段：它们所传达的信息如今可以由继承体系自身传达。以Self Encapsulate Field避免直接使用这些字段，然后将它们的取值函数修改为多态常量函数，所有使用到这些字段的地方采用Replace Conditional with Polymorphism重构
5. 编译测试

### 8.7 提炼超类（Extract Superclass）

1. 为原本的类创建一个抽象超类
2. 运用Pull Up Field、Pull Up Method、Pull Up Constructor Body将子类的特性上移到超类中
3. 每次上移后编译测试
4. 检查子类中是否还有通用的代码，如果有，用Extract Method和Pull Up Method将新函数提炼上移到超类中
5. 将所有共通元素都上移到超类中后，检查子类的所有用户，如果它们只使用共同接口，则可以将它们请求的对象类型修改为超类

### 8.8 提炼接口（Extract Interface）

1. 新建一个空接口
2. 在接口声明中声明待提炼类的共通操作
3. 上相关的类实现上述接口
4. 调整客户端的类型声明，令其使用该接口

### 8.9 折叠继承体系（Collapse Hierarchy）

1. 选择你想移除的类：是超类还是子类
2. 使用Pull Up Field和Pull Up Method，或者Pull Down Field和Pull Down Method，把想要移除的类的所有行为和数据搬移到另一个类
3. 每次移动后编译测试
4. 调整即将被移除的那个类的所有引用点，令它们改为调用合并后留下的类。这个动作会影响变量的声明、参数的类型以及构造函数
5. 移除不用的类
6. 编译测试